<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FIBA 3x3 MCQ Quiz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0e1117; --panel:#161b22; --ink:#e6edf3; --muted:#9da7b3; --accent:#f6c945; --good:#2ea043; --bad:#f85149; }
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    header{padding:16px 20px;border-bottom:1px solid #232a34;background:linear-gradient(180deg,#0f1320,#0e1117)}
    h1{margin:0;font-size:18px;letter-spacing:.3px}
    main{max-width:960px;margin:0 auto;padding:20px}
    .card{background:var(--panel);border:1px solid #232a34;border-radius:12px;padding:18px;box-shadow:0 6px 24px rgba(0,0,0,.20)}
    .row{display:flex;gap:18px;flex-wrap:wrap}
    .meta{display:flex;justify-content:space-between;gap:12px;margin:8px 0 14px;color:var(--muted);font-size:13px}
    .progress-wrap{height:8px;background:#0b0f16;border-radius:999px;overflow:hidden;border:1px solid #1f2630}
    .progress{height:100%;background:linear-gradient(90deg,var(--accent),#ffd86b);width:0%}
    .q-text{font-size:18px;margin:10px 0 14px}
    .pill{display:inline-block;background:#111826;border:1px solid #233043;border-radius:999px;padding:6px 10px;color:var(--muted);font-size:12px}
    .options{display:grid;gap:10px}
    .opt{border:1px solid #2a3442;border-radius:10px;padding:12px 14px;cursor:pointer;background:#111826;transition:transform .05s ease,border-color .2s}
    .opt:hover{transform:translateY(-1px)}
    .opt.selected{outline:2px solid #39506b}
    .opt.correct{border-color:var(--good);background:rgba(46,160,67,.12)}
    .opt.incorrect{border-color:var(--bad);background:rgba(248,81,73,.10)}
    .feedback{margin-top:10px;font-size:14px}
    .feedback.good{color:var(--good)} .feedback.bad{color:var(--bad)}
    .controls{display:flex;justify-content:space-between;gap:10px;margin-top:18px}
    button{background:#1f6feb;color:#fff;border:0;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer}
    button.secondary{background:#0b1320;border:1px solid #243044;color:#c8d1dc}
    button:disabled{opacity:.6;cursor:not-allowed}
    .img-wrap{display:flex;justify-content:center;margin:6px 0 12px}
    .img-wrap img{max-width:360px;max-height:220px;width:auto;height:auto;border-radius:10px;border:1px solid #273244;background:#0b0f16}
    .summary h2{margin-top:0}
    .summary .badlist{margin:10px 0 0;padding-left:18px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    details{border:1px dashed #2a3442;border-radius:10px;padding:10px;margin-top:10px}
    details summary{cursor:pointer;color:#d2dbe7}
    .foot{margin-top:18px;color:var(--muted);font-size:12px}
  </style>
</head>
<body>
  <header><h1>FIBA 3x3 Quiz — Playing Rules & Referee Signals</h1></header>
  <main>
    <div class="card">
      <div class="meta">
        <div><span class="pill" id="catPill">Category</span></div>
        <div class="progress-wrap" style="flex:1"><div class="progress" id="progress"></div></div>
        <div><span class="pill" id="countPill">Q 1/1</span></div>
      </div>

      <div id="imageZone" class="img-wrap" style="display:none"></div>
      <div class="q-text" id="qText">Loading…</div>
      <div class="options" id="options"></div>
      <div id="feedback" class="feedback"></div>

      <div class="controls">
        <button id="backBtn" class="secondary">← Back</button>
        <div style="display:flex;gap:10px">
          <button id="nextBtn">Next →</button>
          <button id="finishBtn" style="display:none">Finish</button>
        </div>
      </div>

      <section id="summary" class="summary" style="display:none;margin-top:8px">
        <h2>Summary</h2>
        <p>Total questions: <b id="sumTotal">0</b> &middot; Correct: <b id="sumCorrect">0</b> &middot; Wrong: <b id="sumWrong">0</b></p>
        <details open>
          <summary>Wrong questions & explanations</summary>
          <ol id="wrongList" class="badlist"></ol>
        </details>
        <details>
          <summary>Rule categories to review</summary>
          <ul id="catList" class="badlist"></ul>
        </details>
        <div class="foot">Reload the page to reshuffle questions & options.</div>
      </section>
    </div>

    <!-- Put/keep your full rules text here. The script below will parse it into paragraphs and categories. -->
    <script type="text/plain" id="rules">
PLAYING COURT AND EQUIPMENT

Playing court
A regular 3x3 playing court shall have a flat, hard surface free from obstructions (Diagram 1) with dimensions of 15 m in width and 11 m in length measured from the inner edge of the boundary line. The court shall have a regular basketball playing court sized zone, including a free throw line (5.80 m), a 2-point line (6.75m) and a "no-charge semi-circle" area underneath the basket.

At grassroots level, 3x3 can be played anywhere; court makings - if any are used - shall be adapted to available space, however FIBA 3x3 Official Competitions must fully comply with the above specifications including backstop with the shot clock integrated in the backstop padding.

Lines
All lines shall be of the same colour and drawn in white or other contrasting colour, 5 cm in width and clearly visible.
Boundary line/Boundary area

The playing court shall be limited by the boundary line, consisting of the baseline (behind the basket), endline (opposite the basket) and the sidelines. These lines are not part of the playing court.

There shall be an additional boundary area of 1 m at the endline, 1.5 m at the sidelines (exceptionally for matters of limited space a minimum of 1 m) and 2 m at the baseline around the playing court.

The scorer's table and its chairs must be placed behind the endline on the lefthand side (when facing the basket).

Exceptionally (for matters of limited space) in Pro Circuit events the scorer's table may cut the corner at the endline (Diagram 5).
To the side of the scorer's table there shall be 2 seats available (one for each team) for the substitutes (Diagram 4).

Free-throw line, restricted area and free-throw rebound places
The free-throw line shall be drawn parallel to the baseline and endline. It shall have its furthest edge 5.80 m from the inner edge of the baseline and shall be 3.60 m long.

Its mid-point shall lie on the imaginary line joining the mid-point of the endline and baseline.

The restricted area shall be the rectangular area marked on the playing court limited by the baseline, the extended free-throw line and the lines which originate at the baseline, its outer edges being 2.45 m from the mid-point of the baseline and terminating at the outer edge of the extended free-throw line. These lines, excluding the baseline, are part of the restricted area.

2-point field goal area
The teams' 2-point field goal area shall be the entire floor area of the playing court, except for the area inside the arc, limited by and including:
• The 2 parallel lines extending from and perpendicular to the baseline, with the outer edge 0.90 m from the inner edge of the sidelines.
• An arc of radius 6.75 m measured from the point on the floor beneath the exact centre of the basket to the outer edge of the arc. The distance of the point on the floor from the inner edge of the mid-point of the baseline is 1.575 m. The arc is joined to the parallel lines.

The 2-point line (the arc) is not part of the 2-point field goal area.

No-charge semi-circle area
The no-charge semi-circle area shall be marked on the playing court, limited by:
• A semi-circle with the radius of 1.25 m measured from the point on the floor beneath the exact centre of the basket to the inner edge of the semi-circle. The semi-circle is joined to:
• The 2 parallel lines perpendicular to the baseline, the inner edge 1.25 m from the point on the floor beneath the exact centre of the basket, 0.375 m in length and ending 1.20 m from the inner edge of the baseline.

The no-charge semi-circle area is completed by imaginary lines joining the ends of the parallel lines directly below the front edges of the backboard

The no-charge semi-circle line is part of the no-charge semi-circle area.

Equipment
The following equipment shall be required:
• Backstop unit, consisting of:
- Backboard
- Basket comprising (pressure release) ring and net
- Backboard support structure including padding.
3x3 Basketballs
• Game clock
Scoreboard
• Shot clock
2 separate, distinctly different and loud signals, one of each for the
- shot clock operator,
- scorer/timer.
Scoresheet
• Playing floor
Playing court
• Adequate lighting.

TEAMS
Teams

Definition
A team member is eligible to play when he has been authorised to play for a team according to the regulations, including regulations governing age limits, of the organising body of the competition.

A team member is entitled to play when his name has been entered on the scoresheet before the beginning of the game and as long as he has not been disqualified.

During playing time, a team member is:
• A player when he is on the playing court and is entitled to play.
• A substitute when he is not on the playing court but he is entitled to play.

During an interval of play, all team members entitled to play are considered as players.

Rule
Each team shall consist of no more than 4 team members entitled to play (3 players on the court and 1 substitute).

Coaches on the playing court and/or on the seats for substitutes and/or remote coaching from outside the court are not allowed.

A substitute becomes a player after his teammate steps off the court.

Uniforms
... (content continues — full text kept to generate questions)
    </script>

    <script>
      // ------------------ CONFIG: add your referee hand-signal images here ------------------
      // The filename (without extension) is the CORRECT answer.
      const signalImages = [
        // Examples (replace with your real files):
        // "signals/traveling.png",
        // "signals/charging.jpg",
        // "signals/blocking.png",
        // "signals/unsportsmanlike.png",
        // "signals/technical.png"
      ];
      // --------------------------------------------------------------------------------------

      // Small helper: seeded-ish shuffle per load via crypto (ensures different order each visit)
      const rnd = (() => {
        const seed = (crypto.getRandomValues(new Uint32Array(1))[0] >>> 0) / 2**32;
        let s = seed || 0.5;
        return () => (s = (s * 9301 + 49297) % 233280) / 233280;
      })();

      function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(rnd()* (i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

      // Extract rules text and split into [category -> paragraphs]
      const raw = document.getElementById('rules').textContent.trim();
      const lines = raw.split(/\r?\n/);
      const categories = [];
      let current = null;

      function isHeading(line){
        if(!line) return false;
        // a heuristic: lines without periods, short-ish, or ALL CAPS words suggest headings
        const noDot = !/[.!?]$/.test(line.trim());
        const capsish = /^[A-Z0-9 .:;'()/-]+$/.test(line.trim());
        const lenOK = line.trim().length <= 42;
        return (capsish && lenOK) || (noDot && lenOK && /^[A-Z]/.test(line.trim()));
      }
      const catMap = {}; // {cat: [paragraphs]}
      let buf = [];

      for(const l of lines){
        const line = l.replace(/\s+$/,'');
        if(isHeading(line)){
          if(buf.length && current){
            const para = buf.join(' ').trim();
            if(para) (catMap[current] ??= []).push(para);
            buf = [];
          }
          current = line.trim().replace(/\s+/g,' ').toUpperCase();
          if(!categories.includes(current)) categories.push(current);
          continue;
        }
        if(line.trim()===''){ // paragraph break
          const para = buf.join(' ').trim();
          if(para && current){
            (catMap[current] ??= []).push(para);
          }
          buf = [];
        } else {
          buf.push(line.trim());
        }
      }
      if(buf.length && current){
        const para = buf.join(' ').trim();
        if(para) (catMap[current] ??= []).push(para);
      }

      // Utility: clean paragraph to a concise statement (basic paraphrase-lite)
      function concise(p){
        let s = p.replace(/\s+/g,' ').trim();
        // drop parenthetical diagram references etc.
        s = s.replace(/\(Diagram[^)]+\)/gi,'').replace(/\(see[^)]+\)/gi,'');
        // shorten long paragraphs
        if(s.length>320){
          s = s.slice(0,300).replace(/[,;:]?\s+\S+$/,'') + '…';
        }
        return s;
      }

      // Distractor generator: tweak numbers & key terms to create clearly different (but relevant) options
      const swaps = [
        ['baseline','sideline'], ['endline','baseline'], ['inside','outside'],
        ['offensive','defensive'], ['defensive','offensive'], ['free throw','field goal'],
        ['field goal','free throw'], ['arc','restricted area'], ['restricted area','no-charge semi-circle'],
        ['12 seconds','10 seconds'], ['10 minutes','12 minutes'], ['2 points','1 point'], ['1 point','2 points'],
        ['6.75 m','6.25 m'], ['5.80 m','5.00 m'], ['1.25 m','1.50 m'], ['1.20 m','1.00 m'],
        ['2 free throws','1 free throw'], ['1 free throw','2 free throws'],
        ['behind the arc','inside the arc'], ['live','dead'], ['dead','live']
      ];
      function tweakOnce(s){
        // numbers
        s = s.replace(/(\d+(?:\.\d+)?)\s?m/g,(_,n)=>{
          const v = parseFloat(n);
          const alt = (v* (1 + (rnd()<.5?-1:1)* (0.1 + rnd()*0.25))).toFixed(2);
          return `${alt} m`;
        });
        s = s.replace(/\b(\d{1,2})\s?seconds?\b/g,(_,n)=>{
          let v = parseInt(n,10);
          v = Math.max(1, v + (rnd()<.5?-1:1)* (1+Math.floor(rnd()*3)));
          return `${v} seconds`;
        });
        s = s.replace(/\b(\d{1,2})\s?minutes?\b/g,(_,n)=>{
          let v = parseInt(n,10);
          v = Math.max(1, v + (rnd()<.5?-1:1)* (1+Math.floor(rnd()*2)));
          return `${v} minutes`;
        });
        // term swaps
        let out = s;
        for(let i=0;i<2;i++){
          const [a,b] = swaps[Math.floor(rnd()*swaps.length)];
          out = out.replace(new RegExp(`\\b${a}\\b`,'i'), b);
        }
        // minor negation flip if present
        if(/\bshall not\b/i.test(out) && rnd()<.4) out = out.replace(/\bshall not\b/ig,'shall');
        else if(/\bshall\b/i.test(out) && rnd()<.2) out = out.replace(/\bshall\b/ig,'shall not');
        return out;
      }
      function distinctDistractors(base, n=4){
        const set = new Set();
        let guard = 0;
        while(set.size<n && guard<60){
          let d = tweakOnce(base);
          // ensure different enough
          if(d!==base && d.length>0 && Math.abs(d.length - base.length)>3 && !set.has(d)) set.add(d);
          guard++;
        }
        // fallbacks if still short
        while(set.size<n){
          set.add(base.split(' ').reverse().join(' '));
        }
        return Array.from(set);
      }

      // Build questions from paragraphs
      const questions = [];
      for(const cat of categories){
        const paras = (catMap[cat]||[]).filter(p => /\w/.test(p));
        for(const p of paras){
          const stem = concise(p);
          if(stem.length < 15) continue;
          const prompt = `Scenario (${cat}): In a 3x3 game situation, which option best aligns with the rule below?`;
          const correct = stem;
          const distractors = distinctDistractors(correct, 4);
          const opts = shuffle([ {t:correct, ok:true}, ...distractors.map(t=>({t,ok:false})) ]);
          questions.push({
            type:'rule',
            category:cat,
            paragraph:p,
            prompt,
            options:opts,
            explain:`Rule reference: <span class="mono">${correct}</span>`
          });
        }
      }

      // Add hand-signal image questions (if any files are configured)
      function filenameBase(path){ return path.split('/').pop().replace(/\.[a-z0-9]+$/i,''); }
      if(signalImages.length){
        const labels = signalImages.map(filenameBase);
        for(const src of signalImages){
          const answer = filenameBase(src);
          const dists = shuffle(labels.filter(x=>x!==answer)).slice(4); // we need 4 distractors -> slice(0,4), but keep clearly distinct
          const pool = shuffle(labels.filter(x=>x!==answer));
          const distractors = (pool.length>=4? pool.slice(0,4) : pool.concat(['blocking','charging','travelling','unsportsmanlike']).slice(0,4));
          const opts = shuffle([ {t:answer, ok:true}, ...distractors.map(t=>({t,ok:false})) ]);
          questions.push({
            type:'signal',
            category:'REFEREE HAND SIGNALS',
            image:src,
            prompt:`Referee Signal: Identify the correct hand signal name.`,
            options:opts,
            explain:`Answer is the image filename: <span class="mono">${answer}</span>`
          });
        }
      }

      // Shuffle questions per visit
      shuffle(questions);

      // State
      const state = {
        i: 0,
        answers: Array(questions.length).fill(null),      // index of chosen option
        correctness: Array(questions.length).fill(null),  // true/false
      };

      // DOM
      const qText = document.getElementById('qText');
      const optionsEl = document.getElementById('options');
      const feedbackEl = document.getElementById('feedback');
      const imageZone = document.getElementById('imageZone');
      const backBtn = document.getElementById('backBtn');
      const nextBtn = document.getElementById('nextBtn');
      const finishBtn = document.getElementById('finishBtn');
      const catPill = document.getElementById('catPill');
      const countPill = document.getElementById('countPill');
      const progressBar = document.getElementById('progress');

      const summaryBox = document.getElementById('summary');
      const sumTotal = document.getElementById('sumTotal');
      const sumCorrect = document.getElementById('sumCorrect');
      const sumWrong = document.getElementById('sumWrong');
      const wrongList = document.getElementById('wrongList');
      const catList = document.getElementById('catList');

      function render(){
        const total = questions.length;
        const idx = state.i;
        const q = questions[idx];

        // header/meta
        catPill.textContent = q.category;
        countPill.textContent = `Q ${idx+1}/${total}`;
        progressBar.style.width = `${((idx)/total)*100}%`;

        // question
        qText.innerHTML = q.prompt;

        // image (signals)
        imageZone.style.display = (q.type==='signal') ? 'flex' : 'none';
        imageZone.innerHTML = '';
        if(q.type==='signal'){
          const img = document.createElement('img');
          img.alt = "Referee Hand Signal";
          img.src = q.image;
          imageZone.appendChild(img);
        }

        // options
        optionsEl.innerHTML = '';
        feedbackEl.textContent = '';
        const previous = state.answers[idx];

        q.options.forEach((opt, k)=>{
          const div = document.createElement('div');
          div.className = 'opt';
          div.setAttribute('role','button');
          div.setAttribute('tabindex','0');
          div.innerHTML = `<b>${String.fromCharCode(65+k)}.</b> ${opt.t}`;
          if(previous===k){
            div.classList.add('selected');
            // show correctness immediately on revisit
            if(state.correctness[idx] !== null){
              div.classList.add(opt.ok ? 'correct' : 'incorrect');
              feedbackEl.className = 'feedback ' + (state.correctness[idx] ? 'good' : 'bad');
              feedbackEl.innerHTML = state.correctness[idx]
                ? '✔ Correct!' 
                : `✖ Incorrect. ${q.explain}`;
            }
          }
          div.addEventListener('click',()=>{
            state.answers[idx] = k;
            // mark selection
            [...optionsEl.children].forEach(c=>c.classList.remove('selected','correct','incorrect'));
            div.classList.add('selected');

            // grade & reveal
            const ok = q.options[k].ok===true;
            state.correctness[idx] = ok;

            if(ok){
              div.classList.add('correct');
              feedbackEl.className = 'feedback good';
              feedbackEl.textContent = '✔ Correct!';
            } else {
              div.classList.add('incorrect');
              feedbackEl.className = 'feedback bad';
              feedbackEl.innerHTML = `✖ Incorrect. ${q.explain}`;
              // also reveal which was correct
              [...optionsEl.children].forEach((c,ci)=>{
                if(q.options[ci].ok) c.classList.add('correct');
              });
            }
            maybeAutoAdvance();
          });
          optionsEl.appendChild(div);
        });

        // controls
        backBtn.disabled = idx===0;
        const last = idx===total-1;
        nextBtn.style.display = last ? 'none':'inline-block';
        finishBtn.style.display = last ? 'inline-block':'none';
        summaryBox.style.display = 'none';
      }

      function maybeAutoAdvance(){
        // Gentle auto-advance after answering (except on last)
        const last = state.i === questions.length-1;
        if(!last){
          setTimeout(()=>{ state.i++; render(); }, 550);
        }
      }

      backBtn.addEventListener('click',()=>{
        if(state.i>0){ state.i--; render(); }
      });
      nextBtn.addEventListener('click',()=>{
        // require an answer before moving on
        if(state.answers[state.i]===null){
          feedbackEl.className = 'feedback bad';
          feedbackEl.textContent = 'Please choose an answer before continuing.';
          return;
        }
        if(state.i < questions.length-1){ state.i++; render(); }
      });
      finishBtn.addEventListener('click',()=>{
        if(state.answers[state.i]===null){
          feedbackEl.className = 'feedback bad';
          feedbackEl.textContent = 'Please choose an answer before finishing.';
          return;
        }
        showSummary();
      });

      function showSummary(){
        const total = questions.length;
        const correct = state.correctness.filter(x=>x===true).length;
        const wrong = total - correct;
        sumTotal.textContent = total;
        sumCorrect.textContent = correct;
        sumWrong.textContent = wrong;

        wrongList.innerHTML = '';
        const catCount = {};
        questions.forEach((q, i)=>{
          if(state.correctness[i]===false){
            const li = document.createElement('li');
            const chosenIdx = state.answers[i];
            const chosen = chosenIdx!=null ? q.options[chosenIdx].t : '(no answer)';
            const correctText = q.options.find(o=>o.ok).t;
            li.innerHTML = `<div style="margin-bottom:6px"><b>Q${i+1} — ${q.category}</b></div>
                             <div><i>Prompt:</i> ${q.prompt}</div>
                             ${q.type==='signal' ? `<div class="img-wrap" style="margin:8px 0"><img src="${q.image}" alt="signal" style="max-width:220px;max-height:140px"></div>`:''}
                             <div style="margin:4px 0">Your answer: <span class="bad">${chosen}</span></div>
                             <div>Correct answer: <span class="good">${correctText}</span></div>
                             <div style="margin-top:4px">${q.explain}</div>`;
            wrongList.appendChild(li);
            catCount[q.category] = (catCount[q.category]||0)+1;
          }
        });

        catList.innerHTML = '';
        Object.entries(catCount).sort((a,b)=>b[1]-a[1]).forEach(([cat,cnt])=>{
          const li = document.createElement('li');
          li.textContent = `${cat} — ${cnt} question(s) to review`;
          catList.appendChild(li);
        });

        progressBar.style.width = '100%';
        summaryBox.style.display = 'block';
        qText.textContent = 'Quiz complete!';
        optionsEl.innerHTML = '';
        imageZone.style.display = 'none';
        feedbackEl.textContent = '';
        backBtn.disabled = true;
        nextBtn.style.display = 'none';
        finishBtn.style.display = 'none';
      }

      // Kick off
      if(questions.length===0){
        qText.textContent = 'No questions could be generated. Please keep the rules text in the page.';
        optionsEl.innerHTML = '';
        document.querySelector('.controls').style.display = 'none';
      }else{
        render();
      }
    </script>
  </main>
</body>
</html>